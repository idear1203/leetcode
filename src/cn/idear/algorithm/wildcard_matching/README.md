Wildcard Matching
-----------------

此题好难！

开始仿照regular matching写了个算法，结果超时了。

学习了<https://github.com/tg123/leetcode/tree/gh-pages/wildcard-matching>。

### 算法思路

根据p串当前位置上的字符可以有如下分类。

1. 问号`?`

2. 星号`*`

3. 与当前字符匹配的情形。

4. 与当前字符不匹配的情形。


#### 本次匹配成功的情形

1和3效果相同，说明本位置匹配成功。直接进行下一次迭代，比较s串和p串下一位置上的字符是否匹配。

#### 本次匹配失败的情形。

4是与当前字符不匹配的情形。如果之前没有遇到`*`，本位置又不匹配，则可以断定s串和p串不匹配。返回false。如果之前遇到`*`，则回滚到最近遇到的
`*`，因为`*`可以匹配任意数量的字符，那么我们增大它匹配的数量。

#### 星号`*`

遇到星号。保存当前s和p串的位置。从p串下一位置开始与s当前位置匹配，这实际上相当于`*`匹配了空串。当p下一位置与s匹配不成功时，重新回到p的下
一位置令之与s下一位置进行匹配，周而复始，直至与s匹配成功。

至于大神README中所说的现代操作系统中的timeMachine，虽然不是很明白，但是觉得很厉害的样子。

这个题理解的并不是很透彻。